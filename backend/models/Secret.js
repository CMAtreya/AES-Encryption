import mongoose from 'mongoose';

const secretSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  name: {
    type: String,
    required: true,
    trim: true
  },
  type: {
    type: String,
    enum: ['login', 'card', 'note', 'identity', 'api_key', 'ssh_key', 'database'],
    default: 'login'
  },
  encryptedData: {
    ciphertext: { type: String, required: true },
    iv: { type: String, required: true },
    salt: { type: String, required: true },
    authTag: { type: String, required: true }
  },
  metadata: {
    // Flexible metadata that is NOT encrypted (for search/organization)
    category: String,
    tags: [String],
    website: String,
    strengthScore: Number,
    securityIssues: [String] // derived by client AI
  },
  isFavorite: {
    type: Boolean,
    default: false
  },
  isActive: {
    type: Boolean,
    default: true
  },
  // Feature: Secret rotation reminders
  expiresAt: {
    type: Date
  },
  rotationInterval: { // in days
    type: Number
  },
  lastRotated: {
    type: Date,
    default: Date.now
  },
  // Feature: One-time access
  oneTimeAccess: {
    enabled: { type: Boolean, default: false },
    token: { type: String, select: false }, // Hashed token? Or just random string if single use.
    encryptedData: { // Encrypted with a temporary key generated by sender
      ciphertext: String,
      iv: String,
      salt: String,
      authTag: String
    },
    viewed: { type: Boolean, default: false },
    expiresAt: Date
  },
  // Feature: Team sharing
  sharedWith: [{
    userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
    role: { type: String, enum: ['viewer', 'editor', 'admin'], default: 'viewer' },
    // For zero-knowledge sharing, we would need to store the secret's key encrypted with the recipient's public key.
    // For now, we'll add a placeholder field.
    encryptedKey: String
  }],
  accessCount: {
    type: Number,
    default: 0
  },
  lastAccessed: Date
}, {
  timestamps: true
});

// Methods
secretSchema.methods.trackAccess = function () {
  this.accessCount += 1;
  this.lastAccessed = Date.now();
  return this.save();
};

const Secret = mongoose.model('Secret', secretSchema);
export default Secret;
